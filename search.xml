<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode95题题解</title>
    <url>/2020/09/22/leetcode95%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p>
<p> 示例：</p>
<p>输入：3<br>输出：<br>[[1,null,3,2],[3,2,null,1],[3,1,null,null,2],[2,1,3],[1,null,2,null,3]]<br>解释：<br>以上的输出对应以下 5 种不同结构的二叉搜索树：</p>
<p>   1         3     3      2      1<br>    \       /     /      / \      <br>     3     2     1      1   3      2<br>    /     /       \                 <br>   2     1         2                 3</p>
<p>提示：</p>
<p>0 &lt;= n &lt;= 8</p>
<p>这个题解从如何构建二叉树开始，一步步教怎么枚举所有的可能性。可以学会构建二叉树和穷举可能性这两种方法。</p>
<a id="more"></a>

<p>作者：antione<br>链接：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/solution/cong-gou-jian-dan-ke-shu-dao-gou-jian-suo-you-shu-/">https://leetcode-cn.com/problems/unique-binary-search-trees-ii/solution/cong-gou-jian-dan-ke-shu-dao-gou-jian-suo-you-shu-/</a><br>来源：力扣（LeetCode）</p>
<h3 id="构建一颗二叉搜索树"><a href="#构建一颗二叉搜索树" class="headerlink" title="构建一颗二叉搜索树"></a>构建一颗二叉搜索树</h3><p>构建一颗二叉搜索树很简单，只需要选择一个根结点，然后递归去构建其左右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">createBinaryTree</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt; end)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里可以选择从start到end的任何一个值做为根结点，</span></span><br><span class="line">    <span class="comment">// 这里选择它们的中点，实际上，这样构建出来的是一颗平衡二叉搜索树</span></span><br><span class="line">    <span class="keyword">int</span> val = (start + end) / <span class="number">2</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line"></span><br><span class="line">    root.left = helper(start, val - <span class="number">1</span>);</span><br><span class="line">    root.right = helper(val + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>要构建多颗二叉树，问题就在于如何选择不同的根节点，以构建不同的树和子树。</p>
<p>在上面的代码中，在选择根结点的时候，可以这样改造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择所有可能的根结点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果按照上述递归函数的方法写，每次递归只能返回一颗树，我们需要的是多颗树，我们可以将不同的根结点装入<code>List</code>然后返回，实际上，上述代码可以改写成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">helper</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">        list.add(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 装入所有根结点</span></span><br><span class="line">        list.add(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然，现在问题变成了如何构建root的左右子树，我们抛开复杂的递归函数，只关心递归的返回值，每次选择根结点root，我们</p>
<p>递归构建左子树，并拿到左子树所有可能的根结点列表left<br>递归构建右子树，并拿到右子树所有可能的根结点列表right<br>这个时候我们有了左右子树列表，我们的左右子树都是各不相同的，因为根结点不同，我们如何通过左右子树列表构建出所有的以root为根的树呢？</p>
<p>我们固定一个左孩子，遍历右子树列表，那么以当前为root根结点的树个数就为left.size() * right.size()个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">helper</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            <span class="comment">// 如果当前子树为空，不加null行吗？</span></span><br><span class="line">            list.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="comment">// 想想为什么这行不能放在这里，而放在下面？</span></span><br><span class="line">            <span class="comment">// TreeNode root = new TreeNode(i);</span></span><br><span class="line">            List&lt;TreeNode&gt; left = helper(start, i-<span class="number">1</span>);  </span><br><span class="line">            List&lt;TreeNode&gt; right = helper(i+<span class="number">1</span>, end); </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 固定左孩子，遍历右孩子</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode l : left)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode r : right)&#123;</span><br><span class="line">                    TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.left = l;</span><br><span class="line">                    root.right = r;</span><br><span class="line">                    list.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于TreeNode root = new TreeNode(i)的放置的位置问题<br>如果这行代码放置在注释的地方，会造成一个问题，就是以当前为root根结点的树个数就<br>num = left.size() * right.size() &gt; 1时，num棵子树会共用这个root结点，在下面两层for循环中，root的左右子树一直在更新，如果每次不新建一个root，就会导致num个root为根节点的树都相同。</p>
<p>关于如果当前子树为空，不加null行不行的问题<br>显然，如果一颗树的左子树为空，右子树不为空，要正确构建所有树，依赖于对左右子树列表的遍历，也就是上述代码两层for循环的地方，如果其中一个列表为空，那么循环都将无法进行。</p>
]]></content>
      <categories>
        <category>leetcode优秀题解摘录</category>
      </categories>
      <tags>
        <tag>别人脑子就是好使</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode78题题解</title>
    <url>/2020/09/22/leetcode78%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>leetcode78题给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例:</p>
<p>输入: nums = [1,2,3]<br>输出:<br>[[3],[1],[2],[1,2,3],[1,3],[2,3],[1,2],[]]</p>
<p>这篇题解使用了回溯、递归、位运算、建立树然后中序遍历的方法。我认为讲的很透彻，而且对于学习这四种方法是一个很好地例子。原地址有作者画的图，更有助于理解，这篇文章主要用于摘录我就不照搬了。</p>
<a id="more"></a>

<p>文章出处：leetcode78题题解</p>
<p>作者：sdwwld<br>链接：<a href="https://leetcode-cn.com/problems/subsets/solution/hui-su-wei-yun-suan-di-gui-deng-gong-4chong-fang-s/">https://leetcode-cn.com/problems/subsets/solution/hui-su-wei-yun-suan-di-gui-deng-gong-4chong-fang-s/</a><br>来源：力扣（LeetCode）</p>
<h3 id="1，非递归解决"><a href="#1，非递归解决" class="headerlink" title="1，非递归解决"></a>1，非递归解决</h3><p>首先来看一下非递归的解题思路，比如先加入一个空集让他成为新的子集，然后每遍历一个元素就在原来的子集的后面追加这个值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span> &lt;&lt; nums.length);</span><br><span class="line">    <span class="comment">//先添加一个空的集合</span></span><br><span class="line">    res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">//每遍历一个元素就在之前子集中的每个集合追加这个元素，让他变成新的子集</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = res.size(); i &lt; j; i++) &#123;</span><br><span class="line">            <span class="comment">//遍历之前的子集，重新封装成一个新的子集</span></span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(res.get(i));</span><br><span class="line">            <span class="comment">//然后在新的子集后面追加这个元素</span></span><br><span class="line">            list.add(num);</span><br><span class="line">            <span class="comment">//把这个新的子集添加到集合中</span></span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改为递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span> &lt;&lt; nums.length);</span><br><span class="line">    res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    recursion(nums, <span class="number">0</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数组中的元素都访问完了，直接return</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= nums.length)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> size = res.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(res.get(j));</span><br><span class="line">        <span class="comment">//然后在新的子集后面追加一个值</span></span><br><span class="line">        list.add(nums[index]);</span><br><span class="line">        res.add(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归下一个元素</span></span><br><span class="line">    recursion(nums, index + <span class="number">1</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2，回溯解决解决"><a href="#2，回溯解决解决" class="headerlink" title="2，回溯解决解决"></a>2，回溯解决解决</h3><p>之前讲450，什么叫回溯算法，一看就会，一写就废中提到过子集的问题，这里再来看一下。回溯的模板如下，就是先选择，最后再撤销</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="string">&quot;原始参数&quot;</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//终止条件(递归必须要有终止条件)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;终止条件&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">//一些逻辑操作（可有可无，视情况而定）</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="string">&quot;for循环开始的参数&quot;</span>; i &lt; <span class="string">&quot;for循环结束的参数&quot;</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//一些逻辑操作（可有可无，视情况而定）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//做出选择</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        backtrack(<span class="string">&quot;新的参数&quot;</span>);</span><br><span class="line">        <span class="comment">//一些逻辑操作（可有可无，视情况而定）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//撤销选择</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题也一样，可以把它想象成为一颗n叉树，通过DFS遍历这棵n叉树，他所走过的所有路径都是子集的一部分，看下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//走过的所有路径都是子集的一部分，所以都要加入到集合中</span></span><br><span class="line">    list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">//做出选择</span></span><br><span class="line">        tempList.add(nums[i]);</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        backtrack(list, tempList, nums, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//撤销选择</span></span><br><span class="line">        tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3，位运算解决"><a href="#3，位运算解决" class="headerlink" title="3，位运算解决"></a>3，位运算解决</h3><p>数组中的每一个数字都有选和不选两种状态，我们可以用0和1表示，0表示不选，1表示选择。如果数组的长度是n，那么子集的数量就是2^n。比如数组长度是3，就有8种可能，分别是</p>
<p>[0，0，0]</p>
<p>[0，0，<strong>1</strong>]</p>
<p>[0，<strong>1</strong>，0]</p>
<p>[0，<strong>1</strong>，<strong>1</strong>]</p>
<p>[<strong>1</strong>，0，0]</p>
<p>[<strong>1</strong>，0，<strong>1</strong>]</p>
<p>[<strong>1</strong>，<strong>1</strong>，0]</p>
<p>[<strong>1</strong>，<strong>1</strong>，<strong>1</strong>]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">//子集的长度是2的nums.length次方，这里通过移位计算</span></span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">1</span> &lt;&lt; nums.length;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(length);</span><br><span class="line">    <span class="comment">//遍历从0到length中间的所有数字，根据数字中1的位置来找子集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="comment">//如果数字i的某一个位置是1，就把数组中对</span></span><br><span class="line">            <span class="comment">//应的数字添加到集合</span></span><br><span class="line">            <span class="keyword">if</span> (((i &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                list.add(nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4，其他解决方式"><a href="#4，其他解决方式" class="headerlink" title="4，其他解决方式"></a>4，其他解决方式</h3><p>在426，什么是递归，通过这篇文章，让你彻底搞懂递归中最后讲到分支污染的时候提到过这样一个问题：生成一个2^n长的数组，数组的值从0到(2^n)-1。我们可以把它想象成为一颗二叉树，每个节点的子树都是一个可选一个不可选</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    helper(res, nums, <span class="keyword">new</span> ArrayList&lt;&gt;(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span>[] nums, List&lt;Integer&gt; list, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//终止条件判断</span></span><br><span class="line">    <span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每一个节点都有两个分支，一个选一个不选</span></span><br><span class="line">    <span class="comment">//走不选这个分支</span></span><br><span class="line">    helper(res, nums, list, index + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//走选择这个分支</span></span><br><span class="line">    list.add(nums[index]);</span><br><span class="line">    helper(res, nums, list, index + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//撤销选择</span></span><br><span class="line">    list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode优秀题解摘录</category>
      </categories>
      <tags>
        <tag>别人脑子就是好使</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode144题题解</title>
    <url>/2020/09/24/leetcode144%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>给定一个二叉树，返回它的 前序 遍历。</p>
<p> 示例:</p>
<p>输入: [1,null,2,3]<br>   1<br>    <br>     2<br>    /<br>   3 </p>
<p>输出: [1,2,3]<br>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<p>这个题解把前中后序的迭代和递归都列了出来，可以记一下。</p>
<a id="more"></a>

<p>来源：力扣（LeetCode）</p>
<h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderRecur</span><span class="params">(TreeNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    preOrderRecur(head.left);</span><br><span class="line">    preOrderRecur(head.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderRecur</span><span class="params">(TreeNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    preOrderRecur(head.left);</span><br><span class="line">    System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    preOrderRecur(head.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrderRecur</span><span class="params">(TreeNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrderRecur(head.left);</span><br><span class="line">    postOrderRecur(head.right);</span><br><span class="line">    System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h2><h3 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderIteration</span><span class="params">(TreeNode head)</span> </span>&#123;</span><br><span class="line">	LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; output = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">      TreeNode node = stack.pollLast();</span><br><span class="line">      output.add(node.val);</span><br><span class="line">      <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.add(node.right);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.add(node.left);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderIteration</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrderIteration</span><span class="params">(TreeNode head)</span> </span>&#123;</span><br><span class="line">		 LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; output = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">      TreeNode node = stack.pollLast();</span><br><span class="line">      output.addFirst(node.val);</span><br><span class="line">      <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.add(node.left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.add(node.right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode优秀题解摘录</category>
      </categories>
      <tags>
        <tag>别人脑子就是好使</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode450题题解</title>
    <url>/2020/09/27/leetcode450%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<p>首先找到需要删除的节点；<br>如果找到了，删除它。</p>
<p>这里讲了二叉搜索树的三个性质，可以记一下。</p>
<a id="more"></a>

<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/delete-node-in-a-bst">https://leetcode-cn.com/problems/delete-node-in-a-bst</a></p>
<h2 id="二叉搜索树的三个特性"><a href="#二叉搜索树的三个特性" class="headerlink" title="二叉搜索树的三个特性"></a>二叉搜索树的三个特性</h2><p>这些性质最好在面试之前了解清楚：</p>
<p>二叉搜索树的中序遍历的序列是递增排序的序列。中序遍历的遍历次序：Left -&gt; Node -&gt; Right。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LinkedList&lt;Integer&gt; <span class="title">inorder</span><span class="params">(TreeNode root, LinkedList&lt;Integer&gt; arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> arr;</span><br><span class="line">  inorder(root.left, arr);</span><br><span class="line">  arr.add(root.val);</span><br><span class="line">  inorder(root.right, arr);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>





<p>Successor 代表的是中序遍历序列的下一个节点。即比当前节点大的最小节点，简称后继节点。 先取当前节点的右节点，然后一直取该节点的左节点，直到左节点为空，则最后指向的节点为后继节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">successor</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  root = root.right;</span><br><span class="line">  <span class="keyword">while</span> (root.left != <span class="keyword">null</span>) root = root.left;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>Predecessor 代表的是中序遍历序列的前一个节点。即比当前节点小的最大节点，简称前驱节点。先取当前节点的左节点，然后取该节点的右节点，直到右节点为空，则最后指向的节点为前驱节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">predecessor</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  root = root.left;</span><br><span class="line">  <span class="keyword">while</span> (root.right != <span class="keyword">null</span>) root = root.right;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h4 id="方法：递归"><a href="#方法：递归" class="headerlink" title="方法：递归"></a>方法：递归</h4><p>这里有三种可能的情况：</p>
<ul>
<li><p>要删除的节点为叶子节点，可以直接删除。</p>
</li>
<li><p>要删除的几点不是叶子节点且拥有右节点，则该节点可以由该节点的后继节点进行替代，该后继节点位于右子树中较低的位置。然后可以从后继节点的位置递归向下操作以删除后继节点。</p>
</li>
<li><p>要删除的节点不是叶子节点，且没有右节点但是有左节点。这意味着它的后继节点在它的上面，但是我们并不想返回。我们可以使用它的前驱节点进行替代，然后再递归的向下删除前驱节点。</p>
</li>
</ul>
<p>算法：</p>
<ul>
<li>如果 key &gt; root.val，说明要删除的节点在右子树，root.right = deleteNode(root.right, key)。</li>
<li>如果 key &lt; root.val，说明要删除的节点在左子树，root.left = deleteNode(root.left, key)。</li>
<li>如果 key == root.val，则该节点就是我们要删除的节点，则：<ul>
<li>如果该节点是叶子节点，则直接删除它：root = null。</li>
<li>如果该节点不是叶子节点且有右节点，则用它的后继节点的值替代 root.val = successor.val，然后删除后继节点。</li>
<li>如果该节点不是叶子节点且只有左节点，则用它的前驱节点的值替代 root.val = predecessor.val，然后删除前驱节点。<br>返回 root。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">successor</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        root = root.right;</span><br><span class="line">        <span class="keyword">while</span>(root.left!=<span class="keyword">null</span>) root = root.left;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">predecessor</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        root = root.left;</span><br><span class="line">        <span class="keyword">while</span>(root.right!=<span class="keyword">null</span>) root = root.right;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(key&gt;root.val)&#123;</span><br><span class="line">            root.right = deleteNode(root.right, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;root.val)&#123;</span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>) root = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                root.val = successor(root);</span><br><span class="line">                root.right = deleteNode(root.right, root.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                root.val = predecessor(root);</span><br><span class="line">                root.left = deleteNode(root.left,root.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode优秀题解摘录</category>
      </categories>
      <tags>
        <tag>别人脑子就是好使</tag>
      </tags>
  </entry>
</search>
