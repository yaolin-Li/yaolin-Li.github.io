<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode78题题解</title>
    <url>/2020/09/22/leetcode78%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>leetcode78题给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例:</p>
<p>输入: nums = [1,2,3]<br>输出:<br>[[3],[1],[2],[1,2,3],[1,3],[2,3],[1,2],[]]</p>
<p>这篇题解使用了回溯、递归、位运算、建立树然后中序遍历的方法。我认为讲的很透彻，而且对于学习这四种方法是一个很好地例子。原地址有作者画的图，更有助于理解，这篇文章主要用于摘录我就不照搬了。</p>
<a id="more"></a>

<p>文章出处：leetcode78题题解</p>
<p>作者：sdwwld<br>链接：<a href="https://leetcode-cn.com/problems/subsets/solution/hui-su-wei-yun-suan-di-gui-deng-gong-4chong-fang-s/">https://leetcode-cn.com/problems/subsets/solution/hui-su-wei-yun-suan-di-gui-deng-gong-4chong-fang-s/</a><br>来源：力扣（LeetCode）</p>
<h3 id="1，非递归解决"><a href="#1，非递归解决" class="headerlink" title="1，非递归解决"></a>1，非递归解决</h3><p>首先来看一下非递归的解题思路，比如先加入一个空集让他成为新的子集，然后每遍历一个元素就在原来的子集的后面追加这个值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span> &lt;&lt; nums.length);</span><br><span class="line">    <span class="comment">//先添加一个空的集合</span></span><br><span class="line">    res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">//每遍历一个元素就在之前子集中的每个集合追加这个元素，让他变成新的子集</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = res.size(); i &lt; j; i++) &#123;</span><br><span class="line">            <span class="comment">//遍历之前的子集，重新封装成一个新的子集</span></span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(res.get(i));</span><br><span class="line">            <span class="comment">//然后在新的子集后面追加这个元素</span></span><br><span class="line">            list.add(num);</span><br><span class="line">            <span class="comment">//把这个新的子集添加到集合中</span></span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改为递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span> &lt;&lt; nums.length);</span><br><span class="line">    res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    recursion(nums, <span class="number">0</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数组中的元素都访问完了，直接return</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= nums.length)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> size = res.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(res.get(j));</span><br><span class="line">        <span class="comment">//然后在新的子集后面追加一个值</span></span><br><span class="line">        list.add(nums[index]);</span><br><span class="line">        res.add(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归下一个元素</span></span><br><span class="line">    recursion(nums, index + <span class="number">1</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2，回溯解决解决"><a href="#2，回溯解决解决" class="headerlink" title="2，回溯解决解决"></a>2，回溯解决解决</h3><p>之前讲450，什么叫回溯算法，一看就会，一写就废中提到过子集的问题，这里再来看一下。回溯的模板如下，就是先选择，最后再撤销</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="string">&quot;原始参数&quot;</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//终止条件(递归必须要有终止条件)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;终止条件&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">//一些逻辑操作（可有可无，视情况而定）</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="string">&quot;for循环开始的参数&quot;</span>; i &lt; <span class="string">&quot;for循环结束的参数&quot;</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//一些逻辑操作（可有可无，视情况而定）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//做出选择</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        backtrack(<span class="string">&quot;新的参数&quot;</span>);</span><br><span class="line">        <span class="comment">//一些逻辑操作（可有可无，视情况而定）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//撤销选择</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题也一样，可以把它想象成为一颗n叉树，通过DFS遍历这棵n叉树，他所走过的所有路径都是子集的一部分，看下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//走过的所有路径都是子集的一部分，所以都要加入到集合中</span></span><br><span class="line">    list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">//做出选择</span></span><br><span class="line">        tempList.add(nums[i]);</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        backtrack(list, tempList, nums, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//撤销选择</span></span><br><span class="line">        tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3，位运算解决"><a href="#3，位运算解决" class="headerlink" title="3，位运算解决"></a>3，位运算解决</h3><p>数组中的每一个数字都有选和不选两种状态，我们可以用0和1表示，0表示不选，1表示选择。如果数组的长度是n，那么子集的数量就是2^n。比如数组长度是3，就有8种可能，分别是</p>
<p>[0，0，0]</p>
<p>[0，0，<strong>1</strong>]</p>
<p>[0，<strong>1</strong>，0]</p>
<p>[0，<strong>1</strong>，<strong>1</strong>]</p>
<p>[<strong>1</strong>，0，0]</p>
<p>[<strong>1</strong>，0，<strong>1</strong>]</p>
<p>[<strong>1</strong>，<strong>1</strong>，0]</p>
<p>[<strong>1</strong>，<strong>1</strong>，<strong>1</strong>]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">//子集的长度是2的nums.length次方，这里通过移位计算</span></span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">1</span> &lt;&lt; nums.length;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(length);</span><br><span class="line">    <span class="comment">//遍历从0到length中间的所有数字，根据数字中1的位置来找子集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="comment">//如果数字i的某一个位置是1，就把数组中对</span></span><br><span class="line">            <span class="comment">//应的数字添加到集合</span></span><br><span class="line">            <span class="keyword">if</span> (((i &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                list.add(nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4，其他解决方式"><a href="#4，其他解决方式" class="headerlink" title="4，其他解决方式"></a>4，其他解决方式</h3><p>在426，什么是递归，通过这篇文章，让你彻底搞懂递归中最后讲到分支污染的时候提到过这样一个问题：生成一个2^n长的数组，数组的值从0到(2^n)-1。我们可以把它想象成为一颗二叉树，每个节点的子树都是一个可选一个不可选</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    helper(res, nums, <span class="keyword">new</span> ArrayList&lt;&gt;(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span>[] nums, List&lt;Integer&gt; list, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//终止条件判断</span></span><br><span class="line">    <span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每一个节点都有两个分支，一个选一个不选</span></span><br><span class="line">    <span class="comment">//走不选这个分支</span></span><br><span class="line">    helper(res, nums, list, index + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//走选择这个分支</span></span><br><span class="line">    list.add(nums[index]);</span><br><span class="line">    helper(res, nums, list, index + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//撤销选择</span></span><br><span class="line">    list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode优秀题解摘录</category>
      </categories>
      <tags>
        <tag>别人脑子就是好使</tag>
      </tags>
  </entry>
</search>
